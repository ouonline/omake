#include "project.h"
#include <iostream>
#include <fstream>
#include <set>
#include <unistd.h>
using namespace std;

Target* Project::CreateBinary(const char* name) {
    auto t = new BinaryTarget(name);
    m_targets.push_back(t);
    return t;
}

Target* Project::CreateLibrary(const char* name, int type) {
    if ((!(type & LIBRARY_TYPE_SHARED)) && (!(type & LIBRARY_TYPE_STATIC))) {
        cerr << "CreateLibrary() MUST specify `STATIC` or `SHARED`" << endl;
        return nullptr;
    }

    auto t = new LibraryTarget(name, type);
    m_targets.push_back(t);
    return t;
}

Target* Project::GetTarget(const string& name) const {
    for (auto target : m_targets) {
        if (name == target->GetName()) {
            return target;
        }
    }
    return nullptr;
}

static bool WriteFile(const string& fname, const string& content) {
    ofstream ofs;
    ofs.open(fname, ios_base::out | ios_base::trunc);
    if (!ofs.is_open()) {
        return false;
    }

    ofs.write(content.data(), content.size());
    ofs.close();
    return true;
}

static bool HasOMake(const string& dir) {
    return (access((dir + "/omake.lua").c_str(), F_OK) == 0);
}

struct DepInfo {
    DepInfo(const string& _path, const string& _name, const string& _label)
        : path(_path), name(_name), label(_label) {}
    string path;
    string name;
    string label;
};

static inline void InsertDepInfo(const string& path, const string& name,
                                 const string& label, vector<DepInfo>* deplibs) {
    for (auto lib : *deplibs) {
        if (path == lib.path && name == lib.name) {
            return;
        }
    }

    deplibs->emplace_back(DepInfo(path, name, label));
}

static const DepInfo* FindDepInfo(const vector<DepInfo>& deplibs, const string& path,
                                  const string& name) {
    for (size_t i = 0; i < deplibs.size(); ++i) {
        const DepInfo& lib = deplibs[i];
        if (path == lib.path && name == lib.name) {
            return &lib;
        }
    }
    return nullptr;
}

static void GenerateDeplibLabel(const Target* target, vector<DepInfo>* deplibs) {
    const vector<LibInfo>& static_libs = target->GetStaticLibraries();
    const vector<LibInfo>& dynamic_libs = target->GetDynamicLibraries();
    if (static_libs.empty() && dynamic_libs.empty()) {
        return;
    }

    const string dep_prefix = "__omake_dep__";

    for (auto lib : static_libs) {
        if (!HasOMake(lib.path)) {
            continue;
        }

        const string dep_label = dep_prefix + std::to_string(deplibs->size());
        const string dep_name = "lib" + lib.name + ".a";
        InsertDepInfo(lib.path, dep_name, dep_label, deplibs);
    }

    for (auto lib : dynamic_libs) {
        if (!HasOMake(lib.path)) {
            continue;
        }

        const string dep_label = dep_prefix + std::to_string(deplibs->size());
        const string dep_name = "lib" + lib.name + ".so";
        InsertDepInfo(lib.path, dep_name, dep_label, deplibs);
    }
}

bool Project::GenerateMakefile(const string& fname) {
    for (auto target : m_targets) {
        if (!target->Finalize()) {
            return false;
        }
    }

    string content = "# This Makefile is generated by omake: https://github.com/ouonline/omake.git\n\n";

    bool has_c = false, has_cpp = false;
    for (auto target : m_targets) {
        if (!target->GetCppSources().empty()) {
            has_cpp = true;
        }
        if (!target->GetCSources().empty()) {
            has_c = true;
        }
    }

    content += "AR := ar\n";
    if (has_c) {
        content += "CC := gcc\n"
            "\n"
            "ifeq ($(debug), y)\n"
            "\tCFLAGS := -g\n"
            "else\n"
            "\tCFLAGS := -O2 -DNDEBUG\n"
            "endif\n"
            "CFLAGS := $(CFLAGS) -Wall -Werror -Wextra -fPIC\n"
            "\n";
    }
    if (has_cpp) {
        content += "CXX := g++\n"
            "\n"
            "ifeq ($(debug), y)\n"
            "\tCXXFLAGS := -g\n"
            "else\n"
            "\tCXXFLAGS := -O2 -DNDEBUG\n"
            "endif\n"
            "CXXFLAGS := $(CXXFLAGS) -Wall -Werror -Wextra -fPIC\n"
            "\n";
    }

    content += "TARGET :=";
    for (auto target : m_targets) {
        target->ForeachGeneratedNameAndCommand(
            [&content] (const string& name, const string&) {
                content += " " + name;
            });
    }
    content += "\n\n";

    content += ".PHONY: all clean\n"
        "\n"
        "all: $(TARGET)\n"
        "\n";

    // pre process for dependencies
    vector<DepInfo> deplibs;
    for (auto target : m_targets) {
        GenerateDeplibLabel(target, &deplibs);
    }
    if (!deplibs.empty()) {
        content += ".PHONY:";
        for (auto it : deplibs) {
            content += " " + it.label;
        }
        content += "\n\n";

        for (auto it : deplibs) {
            content += it.label + ":\n" +
                "\t$(MAKE) debug=$(debug) " + it.name + " -C " + it.path + "\n\n";
        }
    }

    for (auto target : m_targets) {
        vector<pair<string, string>> target_cpp_obj_files;
        vector<pair<string, string>> target_c_obj_files;

        const string obj_name = target->GetName() + "_OBJS";
        content += obj_name + " :=";
        for (auto src : target->GetCppSources()) {
            const string obj_name = src + "." + target->GetName() + ".o";
            target_cpp_obj_files.push_back(make_pair(obj_name, src));
            content += " " + obj_name;
        }
        for (auto src : target->GetCSources()) {
            const string obj_name = src + "." + target->GetName() + ".o";
            target_c_obj_files.push_back(make_pair(obj_name, src));
            content += " " + obj_name;
        }
        content += "\n\n";

        content += target->GetName() + "_INCLUDE :=" + target->GetIncludeClause() +
            "\n\n" +
            target->GetName() + "_LIBS :=" + target->GetLibClause() +
            "\n\n";

        for (auto obj : target_cpp_obj_files) {
            content += obj.first + ": " + obj.second + "\n" +
                "\t$(CXX) $(CXXFLAGS) $(" + target->GetName() + "_INCLUDE) -c $< -o $@\n\n";
        }

        for (auto obj : target_c_obj_files) {
            content += obj.first + ": " + obj.second + "\n" +
                "\t$(CC) $(CFLAGS) $(" + target->GetName() + "_INCLUDE) -c $< -o $@\n\n";
        }
    }

    for (auto target : m_targets) {
        target->ForeachGeneratedNameAndCommand([&target, &deplibs, &content] (const string& name, const string& cmd) {
            content += name + ": $(" + target->GetName() + "_OBJS)";

            if ((!target->GetStaticLibraries().empty()) || (!target->GetDynamicLibraries().empty())) {
                content += " |";
            }

            for (auto lib : target->GetStaticLibraries()) {
                const string& dep_name = "lib" + lib.name + ".a";
                auto dep_info = FindDepInfo(deplibs, lib.path, dep_name);
                if (dep_info) {
                    content += " " + dep_info->label;
                }
            }

            for (auto lib : target->GetDynamicLibraries()) {
                const string& dep_name = "lib" + lib.name + ".so";
                auto dep_info = FindDepInfo(deplibs, lib.path, dep_name);
                if (dep_info) {
                    content += " " + dep_info->label;
                }
            }

            content += "\n"
                "\t" + cmd + "\n\n";
        });
    }

    content += "clean:\n"
        "\trm -f $(TARGET)";
    for (auto target : m_targets) {
        content += " $(" + target->GetName() + "_OBJS)";
    }
    content += "\n";

    return WriteFile(fname, content);
}
