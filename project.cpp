#include "project.h"
#include <iostream>
#include <fstream>
using namespace std;

Target* Project::CreateBinary(const char* name) {
    auto t = new BinaryTarget(name);
    m_targets.push_back(t);
    return t;
}

Target* Project::CreateLibrary(const char* name) {
    auto t = new LibraryTarget(name);
    m_targets.push_back(t);
    return t;
}

Target* Project::GetTarget(const string& name) const {
    for (auto target : m_targets) {
        if (name == target->GetName()) {
            return target;
        }
    }
    return nullptr;
}

static bool WriteFile(const string& fname, const string& content) {
    ofstream ofs;
    ofs.open(fname, ios_base::out | ios_base::trunc);
    if (!ofs.is_open()) {
        return false;
    }

    ofs.write(content.data(), content.size());
    ofs.close();
    return true;
}

bool Project::GenerateMakefile(const string& fname) {
    for (auto target : m_targets) {
        if (!target->Finalize()) {
            return false;
        }
    }

    string content = "# This Makefile is generated by omake: https://github.com/ouonline/omake.git\n\n";

    bool has_c = false, has_cpp = false;
    for (auto target : m_targets) {
        if (!target->GetCppSources().empty()) {
            has_cpp = true;
        }
        if (!target->GetCSources().empty()) {
            has_c = true;
        }
    }

    content += "AR := ar\n";
    if (has_c) {
        content += "CC := gcc\n"
            "\n"
            "ifeq ($(debug), y)\n"
            "\tCFLAGS := -g\n"
            "else\n"
            "\tCFLAGS := -O2 -DNDEBUG\n"
            "endif\n"
            "CFLAGS := $(CFLAGS) -Wall -Werror -Wextra -fPIC\n"
            "\n";
    }
    if (has_cpp) {
        content += "CXX := g++\n"
            "\n"
            "ifeq ($(debug), y)\n"
            "\tCXXFLAGS := -g\n"
            "else\n"
            "\tCXXFLAGS := -O2 -DNDEBUG\n"
            "endif\n"
            "CXXFLAGS := $(CXXFLAGS) -Wall -Werror -Wextra -fPIC\n"
            "\n";
    }

    content += "TARGET :=";
    for (auto target : m_targets) {
        target->ForeachTargetAndCommand([&content] (const string& name, const string&) {
            content += " " + name;
        });
    }
    content += "\n\n";

    content += ".PHONY: all clean\n"
        "\n"
        "all: $(TARGET)\n"
        "\n";

    for (auto target : m_targets) {
        vector<pair<string, string>> target_cpp_obj_files;
        vector<pair<string, string>> target_c_obj_files;

        const string obj_name = target->GetName() + "_OBJS";
        content += obj_name + " :=";
        for (auto src : target->GetCppSources()) {
            const string obj_name = src + "." + target->GetName() + ".o";
            target_cpp_obj_files.push_back(make_pair(obj_name, src));
            content += " " + obj_name;
        }
        for (auto src : target->GetCSources()) {
            const string obj_name = src + "." + target->GetName() + ".o";
            target_c_obj_files.push_back(make_pair(obj_name, src));
            content += " " + obj_name;
        }
        content += "\n\n";

        content += target->GetName() + "_INCLUDE :=" + target->GetIncludeClause() +
            "\n\n" +
            target->GetName() + "_LIBS :=" + target->GetLibClause() +
            "\n\n";

        for (auto obj : target_cpp_obj_files) {
            content += obj.first + ": " + obj.second + "\n" +
                "\t$(CXX) $(CXXFLAGS) $(" + target->GetName() + "_INCLUDE) -c $< -o $@\n\n";
        }

        for (auto obj : target_c_obj_files) {
            content += obj.first + ": " + obj.second + "\n" +
                "\t$(CC) $(CFLAGS) $(" + target->GetName() + "_INCLUDE) -c $< -o $@\n\n";
        }

        auto& static_libs = target->GetStaticLibraries();
        auto& dynamic_libs = target->GetDynamicLibraries();

        if ((!static_libs.empty()) || (!dynamic_libs.empty())) {
            const string pre_process_name = target->GetName() + "_pre_process";
            content += ".PHONY: " + pre_process_name + "\n\n";
            content += "$(" + obj_name + "): | " + pre_process_name + "\n\n" +
                pre_process_name + ":\n";
            for (auto lib : static_libs) {
                content += "\t$(MAKE) debug=$(debug) -C " + lib.path + "\n";
            }
            for (auto lib : dynamic_libs) {
                content += "\t$(MAKE) debug=$(debug) -C " + lib.path + "\n";
            }
            content += "\n";
        }
    }

    for (auto target : m_targets) {
        target->ForeachTargetAndCommand([&content, &target] (const string& name, const string& cmd) {
            content += name + ": $(" + target->GetName() + "_OBJS)\n" +
                "\t" + cmd + "\n\n";
        });
    }

    content += "clean:\n"
        "\trm -f $(TARGET)";
    for (auto target : m_targets) {
        content += " $(" + target->GetName() + "_OBJS)";
    }
    content += "\n";

    return WriteFile(fname, content);
}
